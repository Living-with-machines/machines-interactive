// https://github.com/d3/d3-delaunay Version 3.1.7. Copyright 2018 Observable, Inc.
// https://github.com/mapbox/delaunator Version 2.0.0. Copyright 2017, Mapbox, Inc.
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.d3=t.d3||{})}(this,function(t){"use strict";function e(t){if(!ArrayBuffer.isView(t))throw new Error("Expected coords to be a typed array.");var e=1/0,a=1/0,u=-1/0,c=-1/0,f=t.length>>1,g=this.ids=new Uint32Array(f);this.coords=t;for(var x=0;x<f;x++){var _=t[2*x],d=t[2*x+1];_<e&&(e=_),d<a&&(a=d),_>u&&(u=_),d>c&&(c=d),g[x]=x}var y,m,v,p=(e+u)/2,w=(a+c)/2,T=1/0;for(x=0;x<f;x++){var b=i(p,w,t[2*x],t[2*x+1]);b<T&&(y=x,T=b)}for(T=1/0,x=0;x<f;x++)x!==y&&(b=i(t[2*y],t[2*y+1],t[2*x],t[2*x+1]))<T&&b>0&&(m=x,T=b);var $=1/0;for(x=0;x<f;x++)if(x!==y&&x!==m){var k=s(t[2*y],t[2*y+1],t[2*m],t[2*m+1],t[2*x],t[2*x+1]);k<$&&(v=x,$=k)}if($===1/0)throw new Error("No Delaunay triangulation exists for this input.");if(n(t[2*y],t[2*y+1],t[2*m],t[2*m+1],t[2*v],t[2*v+1])<0){var M=m;m=v,v=M}var A=t[2*y],P=t[2*y+1],E=t[2*m],S=t[2*m+1],z=t[2*v],F=t[2*v+1],L=function(t,e,i,n,s,r){var h=(i-=t)*i+(n-=e)*n,l=(s-=t)*s+(r-=e)*r,o=i*r-n*s;return{x:t+.5*(r*h-n*l)/o,y:e+.5*(i*l-s*h)/o}}(A,P,E,S,z,F);for(this._cx=L.x,this._cy=L.y,function t(e,i,n,s,r,h){var a,u,c;if(s-n<=20)for(a=n+1;a<=s;a++){for(c=e[a],u=a-1;u>=n&&l(i,e[u],c,r,h)>0;)e[u+1]=e[u--];e[u+1]=c}else{var f=n+s>>1;for(u=s,o(e,f,a=n+1),l(i,e[n],e[s],r,h)>0&&o(e,n,s),l(i,e[a],e[s],r,h)>0&&o(e,a,s),l(i,e[n],e[a],r,h)>0&&o(e,n,a),c=e[a];;){do{a++}while(l(i,e[a],c,r,h)<0);do{u--}while(l(i,e[u],c,r,h)>0);if(u<a)break;o(e,a,u)}e[n+1]=e[u],e[u]=c,s-a+1>=u-n?(t(e,i,a,s,r,h),t(e,i,n,u-1,r,h)):(t(e,i,n,u-1,r,h),t(e,i,a,s,r,h))}}(g,t,0,g.length-1,L.x,L.y),this._hashSize=Math.ceil(Math.sqrt(f)),this._hash=[],x=0;x<this._hashSize;x++)this._hash[x]=null;var j=this.hull=r(t,y);this._hashEdge(j),j.t=0,j=r(t,m,j),this._hashEdge(j),j.t=1,j=r(t,v,j),this._hashEdge(j),j.t=2;var U,I,H=2*f-5,K=this.triangles=new Uint32Array(3*H),B=this.halfedges=new Int32Array(3*H);this.trianglesLen=0,this._addTriangle(y,m,v,-1,-1,-1);for(var C=0;C<g.length;C++)if(_=t[2*(x=g[C])],d=t[2*x+1],!(_===U&&d===I||(U=_,I=d,_===A&&d===P||_===E&&d===S||_===z&&d===F))){var D,V=this._hashKey(_,d),Z=V;do{D=this._hash[Z],Z=(Z+1)%this._hashSize}while((!D||D.removed)&&Z!==V);for(j=D;n(_,d,j.x,j.y,j.next.x,j.next.y)>=0;)if((j=j.next)===D)throw new Error("Something is wrong with the input points.");var q=j===D,N=this._addTriangle(j.i,x,j.next.i,-1,-1,j.t);j.t=N,(j=r(t,x,j)).t=this._legalize(N+2),j.prev.prev.t===B[N+1]&&(j.prev.prev.t=N+2);for(var O=j.next;n(_,d,O.x,O.y,O.next.x,O.next.y)<0;)N=this._addTriangle(O.i,x,O.next.i,O.prev.t,-1,O.t),O.prev.t=this._legalize(N+2),this.hull=h(O),O=O.next;if(q)for(O=j.prev;n(_,d,O.prev.x,O.prev.y,O.x,O.y)<0;)N=this._addTriangle(O.prev.i,x,O.i,-1,O.t,O.prev.t),this._legalize(N+2),O.prev.t=N,this.hull=h(O),O=O.prev;this._hashEdge(j),this._hashEdge(j.prev)}this.triangles=K.subarray(0,this.trianglesLen),this.halfedges=B.subarray(0,this.trianglesLen)}function i(t,e,i,n){var s=t-i,r=e-n;return s*s+r*r}function n(t,e,i,n,s,r){return(n-e)*(s-i)-(i-t)*(r-n)}function s(t,e,i,n,s,r){var h=(i-=t)*i+(n-=e)*n,l=(s-=t)*s+(r-=e)*r;if(0===h||0===l)return 1/0;var o=i*r-n*s;if(0===o)return 1/0;var a=.5*(r*h-n*l)/o,u=.5*(i*l-s*h)/o;return a*a+u*u}function r(t,e,i){var n={i:e,x:t[2*e],y:t[2*e+1],t:0,prev:null,next:null,removed:!1};return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function h(t){return t.prev.next=t.next,t.next.prev=t.prev,t.removed=!0,t.prev}function l(t,e,n,s,r){return i(t[2*e],t[2*e+1],s,r)-i(t[2*n],t[2*n+1],s,r)||t[2*e]-t[2*n]||t[2*e+1]-t[2*n+1]}function o(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function a(t){return t[0]}function u(t){return t[1]}e.from=function(t,i,n){i||(i=a),n||(n=u);for(var s=t.length,r=new Float64Array(2*s),h=0;h<s;h++){var l=t[h];r[2*h]=i(l),r[2*h+1]=n(l)}return new e(r)},e.prototype={_hashEdge:function(t){this._hash[this._hashKey(t.x,t.y)]=t},_hashKey:function(t,e){var i=t-this._cx,n=e-this._cy,s=1-i/(Math.abs(i)+Math.abs(n));return Math.floor((2+(n<0?-s:s))/4*this._hashSize)},_legalize:function(t){var e,i,n,s,r,h,l,o,a,u,c=this.triangles,f=this.coords,g=this.halfedges,x=g[t],_=t-t%3,d=x-x%3,y=_+(t+1)%3,m=_+(t+2)%3,v=d+(x+2)%3,p=c[m],w=c[t],T=c[y],b=c[v];if(e=f[2*p],i=f[2*p+1],n=f[2*w],s=f[2*w+1],r=f[2*T],h=f[2*T+1],l=f[2*b],o=f[2*b+1],a=(n-=l)*n+(s-=o)*s,u=(r-=l)*r+(h-=o)*h,(e-=l)*(s*u-a*h)-(i-=o)*(n*u-a*r)+(e*e+i*i)*(n*h-s*r)<0){c[t]=b,c[x]=p,this._link(t,g[v]),this._link(x,g[m]),this._link(m,v);var $=d+(x+1)%3;return this._legalize(t),this._legalize($)}return m},_link:function(t,e){this.halfedges[t]=e,-1!==e&&(this.halfedges[e]=t)},_addTriangle:function(t,e,i,n,s,r){var h=this.trianglesLen;return this.triangles[h]=t,this.triangles[h+1]=e,this.triangles[h+2]=i,this._link(h,n),this._link(h+1,s),this._link(h+2,r),this.trianglesLen+=3,h}};class c{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(t,e){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+e}`}closePath(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(t,e){this._+=`L${this._x1=+t},${this._y1=+e}`}arc(t,e,i){const n=(t=+t)+(i=+i),s=e=+e;if(i<0)throw new Error("negative radius");null===this._x1?this._+=`M${n},${s}`:(Math.abs(this._x1-n)>epsilon||Math.abs(this._y1-s)>epsilon)&&(this._+="L"+n+","+s),i&&(this._+=`A${i},${i},0,1,1,${t-i},${e}A${i},${i},0,1,1,${this._x1=n},${this._y1=s}`)}rect(t,e,i,n){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+e}h${+i}v${+n}h${-i}Z`}value(){return this._||null}}class f{constructor(){this._=[]}moveTo(t,e){this._.push([t,e])}closePath(){this._.push(this._[0].slice())}lineTo(t,e){this._.push([t,e])}value(){return this._.length?this._:null}}class g{constructor(t,[e,i,n,s]=[0,0,960,500]){if(!((n=+n)>=(e=+e)&&(s=+s)>=(i=+i)))throw new Error("invalid bounds");const{points:r,halfedges:h,hull:l,triangles:o}=this.delaunay=t,a=this.circumcenters=new Float64Array(o.length/3*2),u=this.edges=new Uint32Array(h.length),c=this.index=new Uint32Array(r.length),f=this.vectors=new Float64Array(2*r.length);this.xmax=n,this.xmin=e,this.ymax=s,this.ymin=i;for(let t=0,e=0,i=h.length;t<i;++t){const i=o[t];if(c[2*i]!==c[2*i+1])continue;const n=c[2*i]=e;let s=t;do{if(u[e++]=Math.floor(s/3),-1===(s=h[s])){const r=e;s=t;do{if(-1===(s=h[s%3==0?s+2:s-1])||o[s]!==i)break;u[e++]=Math.floor(s/3)}while(s!==t);r<e&&(u.subarray(n,r).reverse(),u.subarray(n,e).reverse());break}if(o[s=s%3==2?s-2:s+1]!==i)break}while(s!==t);c[2*i+1]=e}for(let t=0,e=0,i=o.length;t<i;t+=3,e+=2){const i=2*o[t],n=2*o[t+1],s=2*o[t+2],h=r[i],l=r[i+1],u=r[n],c=r[n+1],f=r[s],g=r[s+1],x=h-u,_=h-f,d=l-c,y=l-g,m=h*h+l*l,v=m-u*u-c*c,p=m-f*f-g*g,w=2*(_*d-x*y);a[e]=(d*p-y*v)/w,a[e+1]=(_*v-x*p)/w}for(let t,e,i,n=l.length,s=2*o[l[n-1]],h=r[s],a=r[s+1],u=0;u<n;++u)t=s,e=h,i=a,h=r[s=2*o[l[u]]],a=r[s+1],f[2*t+2]=f[2*s]=i-a,f[2*t+3]=f[2*s+1]=h-e}render(t){const e=null==t?t=new c:void 0,{delaunay:{halfedges:i,hull:n,triangles:s},circumcenters:r,vectors:h}=this;for(let e=0,n=i.length;e<n;++e){const n=i[e];if(n<e)continue;const s=2*Math.floor(e/3),h=2*Math.floor(n/3),l=r[s],o=r[s+1],a=r[h],u=r[h+1];this._renderSegment(l,o,a,u,t)}for(let e=0,i=n.length;e<i;++e){const i=2*Math.floor(n[e]/3),l=r[i],o=r[i+1],a=4*s[n[e]],u=this._project(l,o,h[a+2],h[a+3]);u&&this._renderSegment(l,o,u[0],u[1],t)}return e&&e.value()}renderBounds(t){const e=null==t?t=new c:void 0;return t.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),e&&e.value()}renderCell(t,e){const i=null==e?e=new c:void 0,n=this._clip(t);if(null!==n){e.moveTo(n[0],n[1]);for(let t=2,i=n.length;t<i;t+=2)e.lineTo(n[t],n[t+1]);return e.closePath(),i&&i.value()}}*cellPolygons(){const{delaunay:{points:t}}=this;for(let e=0,i=t.length/2;e<i;++e){const t=this.cellPolygon(e);t&&(yield t)}}cellPolygon(t){const e=new f;return this.renderCell(t,e),e.value()}_renderSegment(t,e,i,n,s){let r;const h=this._regioncode(t,e),l=this._regioncode(i,n);0===h&&0===l?(s.moveTo(t,e),s.lineTo(i,n)):(r=this._clipSegment(t,e,i,n,h,l))&&(s.moveTo(r[0],r[1]),s.lineTo(r[2],r[3]))}contains(t,e,i){return(e=+e)==e&&(i=+i)==i&&this._step(t,e,i)===t}find(t,e,i=0){if((t=+t)!=t||(e=+e)!=e)return-1;let n;for(;(n=this._step(i,t,e))>=0&&n!==i;)i=n;return n}_step(t,e,i){const{delaunay:{points:n,triangles:s},edges:r,index:h}=this;if(0===n.length)return-1;const l=h[2*t],o=h[2*t+1];if(l===o)return-1;let a=t,u=3*r[l],c=(e-n[2*a])**2+(i-n[2*a+1])**2;switch(t){case s[u]:u=s[u+2];break;case s[u+1]:u=s[u];break;case s[u+2]:u=s[u+1]}let f=(e-n[2*u])**2+(i-n[2*u+1])**2;f<c&&(c=f,a=u);for(let h=l;h<o;++h){switch(u=3*r[h],t){case s[u]:u=s[u+1];break;case s[u+1]:u=s[u+2];break;case s[u+2]:u=s[u]}(f=(e-n[2*u])**2+(i-n[2*u+1])**2)<c&&(c=f,a=u)}return a}_cell(t){const{index:e,edges:i,circumcenters:n}=this,s=e[2*t],r=e[2*t+1];if(s===r)return null;const h=new Float64Array(2*(r-s));for(let t=s,e=0;t<r;++t,e+=2){const s=2*i[t];h[e]=n[s],h[e+1]=n[s+1]}return h}_clip(t){const e=this._cell(t);if(null===e)return null;const{vectors:i}=this,n=4*t;return i[n]||i[n+1]?this._clipInfinite(t,e,i[n],i[n+1],i[n+2],i[n+3]):this._clipFinite(t,e)}_clipFinite(t,e){const i=e.length;let n,s,r,h,l,o=null,a=e[i-2],u=e[i-1],c=this._regioncode(a,u);for(let f=0;f<i;f+=2)if(n=a,s=u,a=e[f],u=e[f+1],r=c,c=this._regioncode(a,u),0===r&&0===c)h=l,l=0,o?o.push(a,u):o=[a,u];else{let e,i,f,g,x;if(0===r){if(null===(e=this._clipSegment(n,s,a,u,r,c)))continue;[i,f,g,x]=e}else{if(null===(e=this._clipSegment(a,u,n,s,c,r)))continue;[g,x,i,f]=e,h=l,l=this._edgecode(i,f),h&&l&&this._edge(t,h,l,o,o.length),o?o.push(i,f):o=[i,f]}h=l,l=this._edgecode(g,x),h&&l&&this._edge(t,h,l,o,o.length),o?o.push(g,x):o=[g,x]}if(o)h=l,l=this._edgecode(o[0],o[1]),h&&l&&this._edge(t,h,l,o,o.length);else if(this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return o}_clipSegment(t,e,i,n,s,r){for(;;){if(0===s&&0===r)return[t,e,i,n];if(s&r)return null;let h,l,o=s||r;8&o?(h=t+(i-t)*(this.ymax-e)/(n-e),l=this.ymax):4&o?(h=t+(i-t)*(this.ymin-e)/(n-e),l=this.ymin):2&o?(l=e+(n-e)*(this.xmax-t)/(i-t),h=this.xmax):(l=e+(n-e)*(this.xmin-t)/(i-t),h=this.xmin),s?(t=h,e=l,s=this._regioncode(t,e)):(i=h,n=l,r=this._regioncode(i,n))}}_clipInfinite(t,e,i,n,s,r){let h,l=Array.from(e);if((h=this._project(l[0],l[1],i,n))&&l.unshift(h[0],h[1]),(h=this._project(l[l.length-2],l[l.length-1],s,r))&&l.push(h[0],h[1]),l=this._clipFinite(t,l))for(let e,i=0,n=l.length,s=this._edgecode(l[n-2],l[n-1]);i<n;i+=2)e=s,s=this._edgecode(l[i],l[i+1]),e&&s&&(i=this._edge(t,e,s,l,i),n=l.length);else this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(l=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return l}_edge(t,e,i,n,s){for(;e!==i;){let i,r;switch(e){case 5:e=4;continue;case 4:e=6,i=this.xmax,r=this.ymin;break;case 6:e=2;continue;case 2:e=10,i=this.xmax,r=this.ymax;break;case 10:e=8;continue;case 8:e=9,i=this.xmin,r=this.ymax;break;case 9:e=1;continue;case 1:e=5,i=this.xmin,r=this.ymin}n[s]===i&&n[s+1]===r||!this.contains(t,i,r)||(n.splice(s,0,i,r),s+=2)}return s}_project(t,e,i,n){let s,r,h,l=1/0;if(n<0){if(e<=this.ymin)return null;(s=(this.ymin-e)/n)<l&&(h=this.ymin,r=t+(l=s)*i)}else if(n>0){if(e>=this.ymax)return null;(s=(this.ymax-e)/n)<l&&(h=this.ymax,r=t+(l=s)*i)}if(i>0){if(t>=this.xmax)return null;(s=(this.xmax-t)/i)<l&&(r=this.xmax,h=e+(l=s)*n)}else if(i<0){if(t<=this.xmin)return null;(s=(this.xmin-t)/i)<l&&(r=this.xmin,h=e+(l=s)*n)}return[r,h]}_edgecode(t,e){return(t===this.xmin?1:t===this.xmax?2:0)|(e===this.ymin?4:e===this.ymax?8:0)}_regioncode(t,e){return(t<this.xmin?1:t>this.xmax?2:0)|(e<this.ymin?4:e>this.ymax?8:0)}}const x=2*Math.PI;class _{constructor(t){const{halfedges:i,hull:n,triangles:s}=new e(t);this.points=t,this.halfedges=i,this.hull=Uint32Array.from(function*(t){let e=t;do{yield e.t}while((e=e.next)!==t)}(n)),this.triangles=s}voronoi(t){return new g(this,t)}render(t){const e=null==t?t=new c:void 0,{points:i,halfedges:n,triangles:s}=this;for(let e=0,r=n.length;e<r;++e){const r=n[e];if(r<e)continue;const h=2*s[e],l=2*s[r];t.moveTo(i[h],i[h+1]),t.lineTo(i[l],i[l+1])}return this.renderHull(t),e&&e.value()}renderPoints(t,e=2){const i=null==t?t=new c:void 0,{points:n}=this;for(let i=0,s=n.length;i<s;i+=2){const s=n[i],r=n[i+1];t.moveTo(s+e,r),t.arc(s,r,e,0,x)}return i&&i.value()}renderHull(t){const e=null==t?t=new c:void 0,{points:i,hull:n,triangles:s}=this,r=n.length;let h,l=2*s[n[r-1]];for(let e=0;e<r;++e)h=l,l=2*s[n[e]],t.moveTo(i[h],i[h+1]),t.lineTo(i[l],i[l+1]);return e&&e.value()}hullPolygon(){const t=new f;return this.renderHull(t),t.value()}renderTriangle(t,e){const i=null==e?e=new c:void 0,{points:n,triangles:s}=this,r=2*s[t*=3],h=2*s[t+1],l=2*s[t+2];return e.moveTo(n[r],n[r+1]),e.lineTo(n[h],n[h+1]),e.lineTo(n[l],n[l+1]),e.closePath(),i&&i.value()}*trianglePolygons(){const{triangles:t}=this;for(let e=0,i=t.length/3;e<i;++e)yield this.trianglePolygon(e)}trianglePolygon(t){const e=new f;return this.renderTriangle(t,e),e.value()}}_.from=function(t,e=function(t){return t[0]},i=function(t){return t[1]},n){return new _("length"in t?function(t,e,i,n){const s=t.length,r=new Float64Array(2*s);for(let h=0;h<s;++h){const s=t[h];r[2*h]=e.call(n,s,h,t),r[2*h+1]=i.call(n,s,h,t)}return r}(t,e,i,n):Float64Array.from(function*(t,e,i,n){let s=0;for(const r of t)yield e.call(n,r,s,t),yield i.call(n,r,s,t),++s}(t,e,i,n)))},t.Delaunay=_,t.Voronoi=g,Object.defineProperty(t,"__esModule",{value:!0})});
